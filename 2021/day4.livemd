# Day 4

## Setup

```elixir
Mix.install([{:kino, "~> 0.4.0"}])
```

```elixir
input = Kino.Input.textarea("Add input:")
```

```elixir
[inps | boards] =
  input
  |> Kino.Input.read()
  |> String.split("\n", trim: true)

nums =
  inps
  |> String.split(",")
  |> Enum.map(&String.to_integer/1)
```

## Key 6

```elixir
defmodule FlatBoard do
  @enforce_keys [:fb]
  defstruct fb: []

  def new(board) when is_list(board) do
    %FlatBoard{fb: board}
  end

  def mark(number, %FlatBoard{fb: fb}) do
    # put_elem(fb[Integer.to_string(number) |> String.to_atom()], 1, true)
    num = Integer.to_string(number) |> String.to_atom()

    fb
    |> Enum.map(fn {k, v} -> if num == k, do: {k, true}, else: {k, v} end)
    |> FlatBoard.new()
    |> won
  end

  defp won(%FlatBoard{fb: fb} = fboard) do
    {row_won?(fb), fboard}
  end

  defp row_won?(fb) when is_list(fb) do
    fb
    |> Enum.chunk_every(5)
    |> Enum.any?(fn x ->
      x
      |> Enum.reduce_while(true, fn {_, ac}, y ->
        if ac and y, do: {:cont, true}, else: {:halt, false}
      end)
    end)
  end

  def col_won?(%FlatBoard{fb: _fb}) do
  end
end

flatboards =
  boards
  |> Enum.chunk_every(5)
  |> Enum.map(
    &(Enum.map(
        &1,
        fn s ->
          String.split(s, " ", trim: true)
          |> Enum.map(fn n -> {String.to_atom(n), false} end)
        end
      )
      |> List.flatten())
  )
  |> Enum.map(&FlatBoard.new/1)

flatboards
|> Enum.reduce_while(
  {},
  fn fb, _ ->
    nums
    |> Enum.reduce_while(
      {false, {false, fb}},
      fn nu, {_, {_, f}} ->
        case FlatBoard.mark(nu, f) do
          {true, f} -> {:halt, {:halt, {true, f}}}
          {false, f} -> {:cont, {:cont, {false, f}}}
        end
      end
    )
  end
)
```
